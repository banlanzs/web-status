# API 速率限制功能说明

## 概述

本项目已实现 UptimeRobot API 速率限制保护机制，符合 FREE plan 的限制（10 req/min）。

## 功能特性

### 1. 智能缓存机制

- **缓存时长**：60 秒
- **自动更新**：缓存过期后，下次请求会自动刷新数据
- **透明使用**：使用缓存时不消耗 API 配额

### 2. 速率限制保护

- **滑动窗口**：使用 60 秒滑动窗口追踪请求
- **配额管理**：自动记录和管理剩余配额
- **降级策略**：配额用尽时自动使用缓存数据

### 3. 用户体验优化

- **无感刷新**：即使频繁刷新页面，也不会超出限制
- **实时反馈**：控制台显示详细的配额和缓存状态
- **错误处理**：配额用尽时返回友好的错误提示

## 工作流程

```
┌─────────────────────────────────────────────────────────────┐
│                    用户请求页面                               │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
           ┌───────────────────────┐
           │ 检查缓存是否有效？      │
           └───────┬───────────────┘
                   │
        ┌──────────┴──────────┐
        │ 是                  │ 否
        ▼                     ▼
┌───────────────┐    ┌────────────────────┐
│ 返回缓存数据   │    │ 检查速率限制       │
│ (不消耗配额)   │    └────────┬───────────┘
└───────────────┘             │
                    ┌─────────┴─────────┐
                    │ 未超限            │ 已超限
                    ▼                   ▼
            ┌──────────────┐    ┌──────────────────┐
            │ 调用 API      │    │ 返回缓存或错误    │
            │ 更新缓存      │    └──────────────────┘
            │ 记录配额使用  │
            └──────────────┘
```

## 配置选项

### 修改速率限制

编辑 `src/lib/rate-limiter.ts`:

```typescript
export const uptimeRobotLimiter = new RateLimiter({
  maxRequests: 10,      // ← 修改为您的套餐限制
  windowMs: 60 * 1000,  // ← 时间窗口（毫秒）
});
```

**不同套餐的配置：**

| 套餐 | maxRequests | windowMs | 说明 |
|-----|-------------|----------|------|
| FREE | 10 | 60000 | 10 req/min |
| Pro | 无限制 | - | 可以移除限制逻辑 |

### 修改缓存时长

编辑 `src/lib/uptimerobot.ts`:

```typescript
const CACHE_TTL = 60 * 1000; // ← 修改为您想要的缓存时长（毫秒）
```

**推荐配置：**

- **高频刷新场景**：120000 (2分钟)
- **正常使用**：60000 (1分钟) ✓ 当前配置
- **低频访问**：30000 (30秒)

## 日志说明

### API 请求日志

```
[API Request] 发起新请求 (剩余配额: 9/10)
```
- 表示发起了一次 API 调用
- 剩余配额从 10 变为 9

### 缓存命中日志

```
[Cache Hit] 返回缓存数据 (缓存年龄: 15秒, 剩余请求: 8/10)
```
- 使用了缓存数据，未调用 API
- 缓存已存在 15 秒
- 当前剩余 8 次 API 请求配额

### 速率限制日志

```
[Rate Limit] API 请求被限制。速率限制: 10 req/min, 重置时间: 45秒后
[Rate Limit] 返回缓存数据 (缓存年龄: 30秒)
```
- 已达到速率限制（10 req/min）
- 45 秒后配额将重置
- 使用缓存数据响应请求

### 缓存更新日志

```
[Cache Updated] 缓存已更新 (13 个监控器)
```
- API 请求成功
- 缓存已更新，包含 13 个监控器数据

## 测试场景

### 场景 1：正常访问

```bash
时间 0s:  第1次请求 → API调用 → 剩余 9/10
时间 10s: 第2次请求 → 使用缓存 → 剩余 9/10
时间 20s: 第3次请求 → 使用缓存 → 剩余 9/10
时间 65s: 第4次请求 → 缓存过期 → API调用 → 剩余 8/10
```

### 场景 2：频繁刷新

```bash
时间 0s:  第1次请求 → API调用 → 剩余 9/10
时间 1s:  第2次请求 → 使用缓存 → 剩余 9/10
时间 2s:  第3次请求 → 使用缓存 → 剩余 9/10
时间 3s:  第4次请求 → 使用缓存 → 剩余 9/10
...无论刷新多少次，都使用缓存
```

### 场景 3：配额耗尽

```bash
1分钟内发起10次独立请求（每次缓存都过期）
第11次: → 速率限制 → 返回缓存或错误信息
等待: 第1次请求过期（60秒后）
第12次: → 配额恢复 → API调用成功
```

## 故障排除

### 问题：仍然触发速率限制

**可能原因：**
1. 缓存时长设置太短
2. 多个用户/实例同时访问
3. Next.js 的 `revalidate` 参数冲突

**解决方案：**
```typescript
// 增加缓存时长
const CACHE_TTL = 120 * 1000; // 2分钟

// 或者关闭 Next.js 的自动重新验证
next: { revalidate: false }, // 在 fetch 调用中
```

### 问题：缓存数据不更新

**可能原因：**
1. 缓存时长过长
2. 服务器重启导致缓存丢失

**解决方案：**
```bash
# 清除缓存并重启
rm -rf .next
npm run dev
```

### 问题：配额计数不准确

**可能原因：**
1. 多个 Next.js 实例（开发环境热重载）
2. 浏览器多个标签页

**解决方案：**
- 这是正常现象，每个进程有独立的速率限制器
- 生产环境建议使用 Redis 等共享存储

## 生产部署建议

### Vercel 部署

```bash
# 环境变量配置
UPTIMEROBOT_API_KEY=your_api_key
NEXT_PUBLIC_REFRESH_INTERVAL_SECONDS=300

# 部署
vercel --prod
```

### 多实例部署

如果使用多个服务器实例，建议：

1. **使用 Redis 共享速率限制状态**
2. **增加缓存时长**（如 2-5 分钟）
3. **配置 CDN 缓存**

## 性能影响

- ✅ **响应时间**：缓存命中 < 100ms
- ✅ **内存占用**：约 50KB（13个监控器）
- ✅ **配额节省**：可节省 90% 以上的 API 调用

## 总结

此速率限制实现：

- ✅ 完全符合 UptimeRobot FREE plan 限制
- ✅ 对用户完全透明
- ✅ 提供详细的调试日志
- ✅ 支持灵活配置
- ✅ 优雅的降级策略

即使用户频繁刷新页面，也不会超过 10 req/min 的限制！
